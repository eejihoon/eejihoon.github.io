+++
date = '2026-01-02T16:10:48+09:00'
draft = false
title = '2026 Audit log'
toc = true
autonumber = true
showTags = true
hideBackToTop = false
summary = '01-02~'
+++

## 20260102

오늘 아침 스크래핑 대상에 5천개를 추가할 수 있느냐는 질문을 들었다. 지금 3개 병렬로 5천개를 스크래핑 해오는 것도 6시간에서 많게는 9시간까지 버거운 수준이어서 미뤄달라고 했다. 간단하게는 세션 몇 개 추가해서 병렬 추가 개수를 늘리면 될 것 같았는데 우선 새로 작업하고 있는 에이전시 모델부터 끝내고 처리하려고 미뤘다. 

스크래핑 하는 데 걸리는 시간을 대략적으로 말해주려고 Job 로그를 확인해보는데 31일부터 안 돌았다.

확인해보니 모든 CRON 관련 작업이 403 Error를 뱉고 있었다.
동시에 새로운 파트너가 결제를 했는데도 권한이 없어서 서비스 탐색이 불가능하다는 제보를 받았다.

1. 결제건에 대해
확인해보니 결제 건에 대한 문제는 만료일이 25.12.15일로 설정되어 있어서 발생하는 문제였는데 원인을 끝내 찾지 못했다. 재현이 안 되고, 똑같이 12.15 만료일로 되어 있는 건들이 수십 건 있었는데 우리가 수기로 데이터를 많이 건드리다보니 원인 추측하기가 불가능했다. 애플리케이션 코드 레벨에서 그 날짜로 넣는 코드가 없었다(시,분,일,초까지 동일한 만료일이 수십건이었음). 이상한 건 전부 시간이 좀 된 데이터였는데, 가장 최근 12.30에 결제가 일어난 건이 만료일이 12.30이라는 것은 잘 이해가 되지 않았다. 애플리케이션 코드 버그라면 만료일이 12.15일 건들과 시, 분, 일, 초까지 같을 수는 없을 것 같았는데 Trigger Function에도 만료일을 건드리는 코드는 없었다.

2. CRON 404에 대해
다른 플랫폼과 협업을 위해 에이전시 모델을 만들고 있다. 파트너에게 서브도메인 형태로 서비스를 제공하려는데, 미들웨어에 허용 가능한 호스트 도메인을 미들웨어에 설정해뒀다가 아예 라우트로 접근을 못하고 403으로 튕겨나가는 이슈가 발생한 것이다.

```ts
const ALLOWED_HOSTS = [
  'example.com',
  'localhost',
  '127.0.0.1',   // 로컬 IP (curl 테스트용)
];

// ---- HOST VALIDATION ----
const isAllowedHost = ALLOWED_HOSTS.some(host =>
  hostname === host || hostname.endsWith(`.${host}`)
);

if (!isAllowedHost) {
  return new NextResponse('Forbidden', { status: 403 });
}
```

호스팅된 서브도메인으로 호출되는데, ALLOWED_HOSTS에서 막히는 것이다. 이렇게까지 강하게 제한할 이유는 없었는데 Claude Code가 제안하는 코드를 따르다보니 아무 생각없이 머지했다. 다행히 예약 메시지 발송 말고 사이드 이펙트는 없었다. 다만 아침부터 예약된 메시지가 한번에 발송되지 않도록 모두 취소하고, 다시 재발송 되도록 만드는 코드를 추가로 작성했다.

이 문제들을 해결하는 중에도 ig 로그인 관련 문의가 들어왔다. 로그인과 Captcha까지 해제했는데 비밀번호가 틀렸다고 한다거나, 로그인을 시도하는데 로그인 화면에서 멈춘다. 1번은 메타 이슈로 우리가 해결할 수 없고 2번은 백로그에 두고 다시 확인해봐야 한다.

연락처가 일원화 되어 있지 않아서 세 군 데 연락처가 저장된다. 연락처가 있는데 왜 알림톡으로 발송되지 않고 DM으로 발송되는 것인지 문의가 들어왔다. 이것도 버그일 거고 나중에 살펴봐야 한다.

---

오늘은 31일에 만들어둔 에이전시 모델 배송지 관리 페이지를 불필요한 코드를 지우고 구현하지 않아도 될 코드를 라이브러리로 대체하고 그런 작업을 계속 반복하고 있다. 클로드 코드가 작성한 코드를 살펴보면서 필요한 부분만 남기고 지워나가는 게 시간이 오래 걸린다. 처음부터 필요한 부분만 필요한 라이브러리를 사용해서 구현하게 할 수는 없을까? 처음부터 코드를 잘 썼으면 괜찮았을지도 모른다. 하지만 이미 스파게티 코드가 되었다. 그럼 스파게티 코드 속에서 어떻게 앞으로 작성할 코드만 불필요한 보일러 플레이트 없이 필요한 부분만 작고 간단하게 잘 만들 수 있을까? 일단 CLAUDE.md를 재작성하고 code-reviews SKILLS를 만들었다. 

```
코드 작성 전 반드시 확인:

[ ] src/hooks/에 재사용 가능한 훅이 있는가?
[ ] src/lib/utils/에 유사 유틸리티가 있는가?
[ ] src/components/ui/에 Shadcn 컴포넌트가 있는가?
[ ] 이 문제는 TanStack Query로 해결되는 표준 패턴인가?
직접 구현 금지 항목:

드롭다운/셀렉트 → Shadcn Select 사용
모달/다이얼로그 → Shadcn Dialog 또는 AlertModal 사용
외부 클릭 감지 → Radix 기본 제공 기능 사용
데이터 페칭 상태 관리 → TanStack Query 사용
URL 쿼리 파라미터 → useFilterParams 훅 사용
```

이 외에도 상세 가이드가 있다. 지켜보면서 내용 추가하는 걸로.

예전부터 보이던 건데 actions에 인증 로직이 너무 중복된다 싶어서 찾아보니 미들웨어랑 중복으로 인증 처리를 하고 있었다.
Next.js에서는 DAL 패턴을 권장한대서 그렇게 수정하는 중이다. DAL 패턴이란? Data Access Layer의 약자로, 데이터베이스와 같은 데이터 저장소에 접근하는 로직을 추상화하여 코드의 복잡성을 줄이고 유지보수성을 향상시키는 패턴이다. Next.js 권장이라는데 왜 몰랐을까? 지금 이 작업을 하는 게 맞을까? 근데 멈출 수가 없다. 미들웨어와 서버 액션에 이중 인증 중복이 있는지 오늘에서야 알았다는 게 어이가 없다. 코드를 거의 안 읽기 때문에 놀랄 일도 아니지만. 난 자격이 없다는 생각이 든다.

-- 

TODO:
- 연락처가 있는데 알림톡 발송 안 되는 이유


## 20260103.

성수집에 가서 이삿짐 정리했다. 집으로 돌아와서 다시 컴퓨터 앞에 앉았다. 오늘 아침에 Claude code 작성자 Boris cherny의 X에 올라온 본인이 클로드 코드를 사용하는 13가지 방법을 공유한 [트윗](https://x.com/bcherny/status/2007179832300581177)을 읽었다. 대단한 내용은 없지만 commit이나 review처럼 매번 내가 타이핑해서 시키는 작업을 커스텀 커맨드로 만들어두고 재사용해야겠다는 생각을 해서 집에 와서 commit과 review custom command를 만들었다. 그리고 어제 하던 DAL 마이그레이션 작업을 마무리 했다. 스파게티 코드가 가장 많은 크리에이터 관련 로직은 아직 수정하지 않았다. 캠페인이나 제안 관련된 코드들을 수정했다. 

어제 결제 버그를 잡아냈다. 다행히 애플리케이션 코드 레벨 문제가 아니라 Trigger Function에서 직접 건드리고 있었다.

```
🎯 발견한 Trigger Function

트리거 이름: trigger_function
실행 함수: apply_pre_registration_benefits()
실행 시점: 테이블에 INSERT될 때

📝 함수 동작 방식

1. specialty가 'fashion'인 경우에만 실행
2. 브랜드 유저의 이메일을 조회
3. 사전 등록 테이블에서 해당 이메일이 사전 등록되어 있는지 확인
4. 사전 등록자라면:
  - 구독 플랜 업그레이드
  - 특정 만료일로 설정
  - 사용 한도 조정
  - Slack으로 알림 발송

💬 메시지 발송 부분

PERFORM public.notify_slack(
  format('사전 등록 브랜드(%s) 가입 확인! 혜택이 자동 적용되었습니다.', v_user_email)
);

변수: v_user_email - moody.brand_users.email에서 조회한 이메일 주소

이 함수는 public.notify_slack() 함수를 호출하여 Slack으로 메시지를 전송합니다.
```

원인을 찾아서 찝찝한 마음이 사라졌다.

구독 > 서비스 사용 > 구독 취소 > 재결제 > 구독 실패 하는 케이스가 있어서 알아봤더니 의도한 동작이었다. Active Plan이 이미 있는데 다시 결제하는 경우, 다개월 결제를 했다가 환불해서 다개월 Active Plan이 있는 상황에서 다시 새로운 plan을 구독할 때 어떻게 할 건지 아직 구체적으로 정해두지 않았기 때문이다. 당장 그런 케이스까지 나오지 않을 것 같아서 구현을 미뤄뒀었다.

worktree script, pr-write, commit custom command 만들고, 거슬리던 어드민 페이지 하나 개선했다. page.tsx에 몰빵해서 너무 커진 페이지를 여러개의 컴포넌트와 hooks로 분리했다. 다개월 구독 시 usage renewal 로직을 제거하고 결제 즉시 다개월 usage를 만들어두도록 수정했다. 간단한 구현인데 왜 이렇게 복잡하게 생각했을까? usage 갱신 크론까지 만들어가면서. 도서관에서 돌아오는 길에 문득 usage를 미리 생성해두면 되잖아? 하는 생각이 들어서 수정했다.

next.js guide를 좀 열심히 읽어야지.

## 20260104

이른 아침부터 형이랑 성수집 짐을 서울여대 사무실로 옮겼다. 2년 전에 녹양동에서 성수동으로 왔었는데 시간이 빠르다. 항상 제때 집을 못 구해서 두 번이나 이사를 해야 하는데도 군말없이 매번 무거운 이삿짐을 옮겨주는 형에게 고맙다.

집 돌아와서 다시 작업. 어제 어드민 페이지를 리팩토링 하다가 CLAUDE.md를 읽더니 Button.tsx 컴포넌트가 Shadcn으로 작성되어 있지 않다고 해서 전체 업데이트를 했다. 커스텀 구현을 라이브러리 코드로 바꾼다고 해서 당장 좋아지는 것은 없으나 특별한 이유가 있지 않고서 shadcn에 이미 구현되어 있는 컴포넌트를 쓰는 게 여러모로 안전한 것 같다. 어느 순간부터 Claude code가 다음 대답까지 예측해서 미리 준비해둔다. 결정하는 일은 언제나 어렵지만 한편으로는 내가 정말 결정을 하고 있는 것인지도 모르겠다. 에이전트랑 일하면서 어느 순간 통제력을 잃어버리는 것 같다. 어떻게 코드가 작성되어 있는지도 잘 모르겠고 나도 모르는 사이에 어떤 문제가 터지지는 않을지, 이미 터진 것은 아닐지 두려워질 때가 많다. AI가 하는 만큼 내가 인지할 수 없는 상황에서 어떻게 통제력을 되찾을 수 있을까? 그냥 조금씩 필요한 부분, 내가 잘 모르겠는 부분을 다시 탐색해나가야겠다는 생각은 하지만, 내 노력과 별개로 통제 가능한 시스템을 구축할 수 있을지 고민이 계속 필요하다.

## 20260105

여섯시 반에 일어나서 영어 듣기 하고 버스타고 출근했다. 버스에서 ELOQUENT JAVASCRIPT를 읽었다.

오전에 세 가지 문제를 공유 받았다.

1. 다른 캠페인에서 이미 제안한 크리에이터가 다시 추천 되어서 같은 크리에이터들에게 제안을 반복한다.
2. 제안 관리에서 크리에이터 확인 불가 / 리빙 서비스에서 패션 서비스 제안 목록 조회 가능한 문제
3. 인스타그램 로그인 시 세션 체크 못함.

그리고 오후에 하나 더 생겼다.

4. 상품 옵션을 지정했는데 지정하지 않고 수락하는 케이스가 있다는 것. 옵션은 필수값인데 누락됐다면 버그다.
이건 이미 수정한 이슈다. 어드민에서 캠페인 대리 제안 기능을 만들었는데 캠페인에서 등록된 상품 옵션을 선택 가능하게 제안 시에도 옵션으로 제공해야 하는데 제안 시 옵션 복사가 안 됐다. 캠페인 옵션과 제안 옵션이 다른 이유는 제안할 때 특정 옵션을 제외할 수 있는 기능을 제공하기 위해서였는데 단순화 과정에서 해당 기능이 없어졌다. 불필요하게 옵션이 이중화 되어 있는 셈이다. 일단 어쩔 수 없다.


1번 문제였던 비슷한 사람들이 여러 캠페인에 걸쳐서 추천되는 문제는 최근 제안한 200명을 추려서 50명 단위로 패널티를 주는 방식으로 해결했다. 최근 50명 안에 포함된다면 *0.2, 최근 100명 안에 포함되면 *0.5 하는 방식이다.

2번 문제는 이상하게 재현이 안 된다. 크리에이터 프로필 페이지로 이동하는 것도 정상 동작하고, 리빙 <-> 패션 크로스 체크해봐도 하나의 분야가 다른 분야의 제안을 조회할 수 없다. 하지만 버그 제보에는 분명히 리빙에서 패션 제안을 조회하고 있다. 데이터를 최대한 비슷하게 꾸려놔도 재현이 불가능하다. 그것 외에 제안 관리 페이지 필터가 분야를 구분하지 않고 통계를 내는 문제가 있어서 수정했고 useEffect, useState로 API Fetch 해오던 부분을 TanStack Query로 변경했다.

H x MOODY 서비스 워크플로우

**(셀러) 캠페인 요청서 작성 -> (무디 어드민) 대리 제안 -> (셀러) 수락한 크리에이터 중 최종 선택 -> (셀러) 콘텐츠 유형에 맞는 금액 정산 -> (셀러) 상품 발송 -> (무디 어드민) 크리에이터 대리 정산 -> (셀러) 완료된 캠페인 콘텐츠 다운로드**

**셀러 서비스**
1. 캠페인 요청서 작성 (미로그인 폼으로 작성하거나 로그인해서 직접 캠페인 생성 가능)
2. 수락한 크리에이터 중 최종 선택
3. 콘텐츠 유형에 맞는 금액 정산
4. 상품 발송
5. 완료된 캠페인 콘텐츠 다운로드

**무디 어드민**
1. 셀러 캠페인 대리 제안
2. 셀러 캠페인 대리 정산


**결제 방식 재논의**

```
결제 시점과 방식을 어떻게 할지
1안) 선결제 방식 - 결제 링크
캠페인 요청서 작성하고, 무디에서 진행 가능 메일 회신 보낼 때 결제 링크 전달
2안) 선결제 방식 - 결제 플로우
캠페인 요청서 작성하고, 결제하기 플로우 제공
3안) 중간 결제 방식
크리에이터 선정 시점에 결제하기 플로우 제공
```

크리에이터는 모였는데 정산하지 않는 경우를 방지하기 위해 3안을 제외하고 1, 2안 중 1안으로 결정.
캠페인 요청서 작성 후, 회신 메일 발송할 때 필요한 결제 링크를 만들어야 하고, 캠페인 진행 과정에서 결제 단계는 생략한다.


**예외 상황**
1. (셀러) 수락한 크리에이터 중 최종 선택
2. (셀러) 콘텐츠 유형에 맞는 금액 정산

셀러는 크리에이터를 최종 선택하고 콘텐츠 유형과 개수에 맞는 금액을 정산한다.
정산 이후에 수락되는 건들에 대한 논의 필요.

> 답변: 우선 기존 플로우대로 한다는 가정하에, 최종 선택 후 수락 건에 대해서는 기본 룰은 반려하고, 상황에 따라 파트너에게 추가 수락건에 대해서 진행 유무 문의 후 드랍

버스 타고 퇴근할 때마다 멀미하는 것 같다. 머리 아프고 어지럽고 울렁거린다.

## 20260106

5시 30분에 6시 30분인 줄 알고 깼다. [The Pragmatic Engineer in 2025](https://newsletter.pragmaticengineer.com/p/the-pragmatic-engineer-in-2025) 읽었다. 요새 A Philosophy of Software Design 이 책 제목을 자주 마주치는 느낌인데, 아쉽게 번역서가 없다. 저자 John Ousterhout과 Gergely Orosz가 The philosophy of software design이라는 제목으로 [팟캐스트](https://newsletter.pragmaticengineer.com/p/the-philosophy-of-software-design)를 진행했는데 생각해보니 작년에 제목에 끌려서 LylisAI로 요약해서 팀에 공유했던 기억이 난다. 나도 풀 비디오를 보지는 않았는데 TDD나 클린 코드에 관한 견해가 재밌었다. TDD와 클린 코드의 도그마 속에서 그렇지 않다고 주장하는 것이 흥미로웠다. 찾아보니 uncle bob과 ousterhout가 만나서 토론도 진행했던 모양이다.

- 테스트가 필요한 가치라고 보면서도 TDD는 전술적(tactical)이어서 오히려 설계를 약하게 만든다고 본다. 
- 개발의 기본 단위를 테스트 1개로 만들면서 사고 단위가 지나치게 작아진다.
- 작동하는 나쁜 코드가 쌓일 위험이 있다.
- 테스트를 문서로 보는 관점에 동의하지 않고 코멘트가 더 효율적이다.
- Outsterhout은 TDD의 대안으로 더 큰 단위의 메서드 혹은 클래스를 먼저 설계-구현한 뒤 곧바로 단위 테스트를 작성하고, 테스트가 갖춰지기 전엔 완료로 보지 않는 방식을 제안했다. 
- 그러면서 예외적인 상황에서 버그를 고치는 경우 테스트 퍼스트가 유용한 점을 인정한다.

결론은 Clean Code든 APOSD든 테스트는 중요하다는 것이다.

7시 30분까지 Ethan Hawke의 Give yourself permission to be creative 비디오를 들었다.

직렬 독서 계속 도전 중이다. 버스타고 오면서 ELOQUENT JAVASCRIPT 읽었다. 버스에서 비동기 부분을 다 읽었다. 주말에 코드도 쳐봐야지. Javascript 코드는 눈으로 읽어서 잘 이해가 안 간다.

출근해서 ig scraper가 프로세싱 상태로 긴 시간 처리되지 않는 케이스가 많아서 10분 이상 프로세싱 중이면 다시 대기 상태로 돌리는 풀링 워커를 작성했다.

공차 마시면서 넥스트 논의. 플랫폼 협업. 버티컬 확장. AI 분석 고도화, 어필리에이트, 자동화 에이전트 등등. 할 일이 많다.
서비스 개발 초기에 대여섯 개 터미널을 열어놓고 병렬 작업을 했는데 어느 순간 내가 무슨 일을 하고 있는 것인지도 모르겠어서 멈췄다. 지금도 가끔 2-3개 병렬로 작업하지만 최대한 한 번에 하나의 일에 집중하려고 한다. 한 두 개 정도 작업을 병렬로 진행하는 것을 시도해봐야겠다.

사용자가 늘어나기 전에 모니터링 시스템 구축해야 한다. 주말에 시간 내서 봐야지.

다시 파트너 플랫폼 작업. AI로 초안 잡고 세부사항 맞추는 게 오래 걸린다. 콘텐츠 다운로드까지 했다.
콘텐츠 관리 페이지에서 업로드 한 이미지를 모두 조회할 수 있어야 한다는 생각이 문득 들었다.

광고 모아보기 페이지에 브랜드 검색 추가 기능 업데이트가 있었다. 좀 느리다고 하길래 살펴보다가 불필요해 보이는 캐시 레이어가 만들어져 있어서 제거를 제안했다. 똑같은 쿼리일 때 같은 결과를 반환하는 캐시 레이어였다. 60초 동안만 유효했다. 클라이언트에 TanStack Query가 Stale 상태가 되기 전까지 그 역할을 대신할 수 있고, 그게 아니더라도 캐시 자체가 느린 쿼리를 해결할 수는 없다고 생각했기 때문이다. 다음과 같은 ORDER BY가 추가 되었다.

```sql
ORDER BY (
  LN(en) * 2 +
  r_score / 100 +
  a_score / 5 * 2 +
  1 / (1 + EPOCH(NOW() - taken_at) / 604800)
) DESC
```

보통의 개발자라면 이런 쿼리를 눈 감고 지나갈 수 없다고 생각한다. 직감적으로 이건 아닌 쿼리가 있는데 이 경우 이건 아님에 해당했다. 그래서 중요도가 높은 게 아니라면 단순화를 제안했더니 API로 변경하면 안 되는 것인지, 로컬에서는 괜찮은데 고객에게 문제가 발생하는 것인지 등등 질문이 돌아왔다. API로 바꾸면 안 되느냐는 말에 달리 무슨 말을 할 수 있을까? 해당 ORDER BY가 비즈니스에서 중요한 정렬이라고 해서 사전에 미리 계산한 값을 쓰기로 했다. 커피를 내렸다.

고씨네 돈까스 먹었다. 의외로 돈까스 맛집이다. 서울여대 후문 들어오는 길에 아파트 방송으로 바깥으로 담배꽁초나 음식물 쓰레기 버리지 말라는 안내방송이 흘렀다. 세상 모든 아파트에서 같은 말을 반복하고 있는 것 같다는 생각이 들었다.

캠페인 생성 > 제안 > 확정 > 출고 > 콘텐츠 다운로드, 대시보드 / 캠페인 관리 페이지까지 얼추 완성했다.

이제 남은 것
- 미로그인 상태로 캠페인 요청 폼
- 관리자 페이지에서 제안/역제안 관리
- 콘텐츠 요청 명세에 따른 결제 페이지 생성
- 취소/환불 절차 (토스페이먼츠 관리자에서 수동 취소 가능)

퇴근 전. 팀에 파트너 어드민 공유함

Weekends TODO
- ELOQUENT JAVASCRIPT 타이핑
- 모니터링 리서치
- npm run build warning 제거

버스 타고 ELOQUENT JAVASCRIPT 읽으면서 퇴근. 1132번 타고 한 정거장 미리 내려서 100번 버스 정류장까지 좀 걸어야 했다.

## 20260107

06:30 알람 맞추고 06:45 기상
06:50 ~ 07:30 영어 공부
07:30 ~ 08:00 출근 준비
08:00 ~ 08:30 커피 타임
08:30 ~ 09:00 ELOQUENT JAVASCRIPT 읽으면서 출근. 프로그래밍 언어 만들기 챕터. 어렵지만 해보고 싶고, 읽을 수록 내공이 대단한 책 같음. 어떤 도구를 내 생각대로 다룰 수 있을 정도로 수련하기 위해서 얼마나 연습했을지 상상하기 어려움.

- 아침에 출근해서 크리에이터가 아닌 인스타그램 사용자에게도 콜드 DM 보낼 수 있도록 기능 추가함.
- IG 스크래퍼가 거의 동작하지 않음. 어제 풀링 워커 추가하고 1000명 스크래핑 할 때까지 문제 없었는데 원인 파악 필요

오늘 할 것
- 미로그인 상태로 캠페인 요청 폼
- 관리자 페이지에서 제안/역제안 관리
- 콘텐츠 요청 명세에 따른 결제 페이지 생성
- 취소/환불 절차 (토스페이먼츠 관리자에서 수동 취소 가능)
- 파트너에게 가는 모든 알림톡 제거

밥 먹고 산책하다가 생각난 것
- campaign request를 별도로 운영해야 할까? 외부적으로 그렇게 노출하더라도 내부적으로 campaigns로 통일해야 하지 않을까? 아니면 언제나 동기화 해주던지. 캠페인 요청서와 캠페인이 분리되어 있으니 로그인할 때 첫 캠페인이 없는 상태다. 이 문제를 해결하려면 생성할 때 캠페인도 같이 생성하거나, 캠페인 요청서도 내부적으로는 캠페인으로 동작하기 해야 한다. 일원화 하는 게 나을지, 동기화 하는 게 나을지?

이슈
- OGT에서 결제하려는데 카드 등록이 안 된다고 함.
 - 처음 한 번 재현이 됐는데 토스페이먼츠에서 거절했다는 문제였고 우리 서비스 로그, 토스페이먼츠 관리자 페이지에 흔적이 남아 있지 않았음.
 - 카드 등록 시 로그 추가해둠
 - PRO 플랜이 이미 있을 경우 결제가 안 되는 문제가 있어서, 수동으로 넣어준 PRO 플랜(빌링 키 없음으로 판단)일 경우 유료 구독 가능하도록 변경

 미로그인 상태로 캠페인 요청 시 자동 가입 + 계정 이메일 발송 등등 끝냈다. 요청 테이블 별도로 두지 않고 캠페인이랑 통합했다. UI 일관성도 맞췄다. 세부사항들 조금 더 테스트 하고 결제로 넘어가도 되겠다.
 
 저녁 샐러디 시켰다. 삼겹 들기름 파스타 샐러드.
 
캠페인 생성 시 결제 페이지 자동 생성 - 결제 기능까지 붙였다. 환불은 나중에.
- 캠페인 관리
  - 파트너 캠페인을 대신 수정할 수 있어야 함
  - 역제안이 오는 경우 수락하거나 다시 제안할 수 있어야 함.

오늘 마무리: 6개 PR 올렸다.
- DM 메시지 예약 기능에 크리에이터 아닌 사용자의 인스타그램 username 추가
- 파트너 캠페인 요청서
- 파트너 캠페인 요청, 캠페인 폼 통합
- 파트너 캠페인 결제 
- 캠페인 관리 어드민
- ig scraper keep-alive 추가
- 원고료 증빙 PDF 다운로드 (갑자기 생긴 일)

비밀번호 찾기, 비밀번호 변경, 비밀번호 재설정 등등.. 자잘한 것들까지.

## 20260108

06:50 ~ 07:30 영어 공부 (Ethan Hakwe Ted, AI Engineer YouTube)

버스타고 09:10 출근했다. 춥다.
오늘도 여전히 ig-job이 돌지 않았다. 어제 대충 Keep-Alive 원인이라고 떼웠던 것이 잘못된 추측이었던 것. Keep-Alive란 무엇인가? “HTTP Keep-Alive는 매 요청마다 TCP 연결을 새로 맺을 때 발생하는 핸드셰이크와 RTT 오버헤드를 줄이기 위해, 한 번 맺은 TCP 연결을 유휴 타임아웃 동안 재사용하는 메커니즘이다. HTTP/1.1에서는 기본적으로 지속 연결을 사용하며, 연결을 끊고 싶으면 `Connection: close` 헤더를 보낸다. 왜 Keep-Alive가 문제였나? 이건 명백히 내가 너무 대충 클로드만 믿고 넘어간 잘못이다. HTTP Keep alive 설정도 아니고 TCP Keep Alive 설정을 해뒀다. TCP 레벨 Keep Alive는 OS 레벨에서 TCP 연결 활성 여부 확인 패킷을 전송한다고 한다. 에러 로그가 Connection terminated due to connection timeout여서 DB랑 연결이 끊겨서 그랬던 것 같다. 하지만 PgBouncer는 애플리케이션 레벨에서 쿼리가 없으면 연결을 종료하고 TCP가 살아있어도 idle timeout이 되면 연결이 끊긴다. 진짜 원인은 이거다.

```
PgBouncer server_idle_timeout: ~10초
pg Pool idleTimeoutMillis: 300초 (5분)
```

시나리오:
1. T+0s: pg Pool이 연결 획득, 쿼리 실행
2. T+1s~60s: 스크래핑 진행 (DB 쿼리 없음)
3. T+10s: PgBouncer가 idle 연결 종료 (pg Pool은 모름)
4. T+61s: 스크래핑 완료, DB 저장 시도
5. pg Pool이 죽은 연결로 쿼리 시도 → 에러 → Worker 크래시

pg Pool이 PgBouncer보다 먼저 연결을 닫도록 설정:
- min: 1 → 0 (idle 연결 유지 안 함)
- idleTimeoutMillis: 300000 → 5000 (5분 → 5초)
- keepAlive 관련 설정 제거 (효과 없음)

--

OGT가 여전히 카드 등록이 안 된다고 문의가 왔다. 정말 감사하고 죄송하다. 재현이 안된다. 데이터를 똑같이 만들고 카드 등록을 시도해도 재현이 안 된다. 정확한 원인 파악을 위해서 계정 정보를 받기 위해 급히 비밀번호 변경 기능을 만들었다. 계정 정보를 받아서 시도했지만 재현이 불가능했다. 카드 정보 입력에 오류가 있었던 것 같다.

오전..은 언제나 이슈 해결로 보내는 것 같다. 뭐가 이렇게 맨날 안 될까?

하루가 정신 없이 갔다. 벌써 여섯 시.
산책하면서 don이 한 말. 뭘 예측하든 다 틀리는 것 같다. 그래서 잘 모르겠고 빨리 해보고 싶다. 

오전 시간 이런저런 이슈 해결하느라 보내고, 오후에 와서도 관리자 페이지 만들고 파트너 어드민 만들고 하느라 순식간에 하루가 다 갔다. 파트너 신청 열기도 전에 어떻게 알고 들어와서 신청했고 매출이 바로 발생했다.

가정의 날이라 여섯 시 퇴근하고 집에 와서 안성탕면이랑 남은 치킨 먹었다. 빨래 개고 청소기 돌리고 집 정리 좀 하니까 아홉시 다 됐다. 잠깐 릴스 봤는데, 보려고 본 것도 아니고 손이 가서 봤는데 한 삽십분이 훅 지난 것 같다. 책 읽는 시간 마련하려고 이번주 내내 버스 타고 다녔는데, 30분이면 얼마나 많은 분량을 읽을 수 있는데 릴스에 30분을 쓰다니 너무 아깝다. 그런 거 알면서도 계속 스크롤 못 멈추는 것도 짜증나고.
