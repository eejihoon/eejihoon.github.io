---
title: "VARCHAR 데이터 타입 상세 분석: 길이, 문자셋, 그리고 CHAR와의 비교"
author: "hoon"
date: "2025-02-25T10:00:00+09:00"
summary: "VARCHAR 타입 학습 기록: 가변 길이 특성, 길이 저장 바이트의 역할, 문자셋(utf8mb4 등)에 따른 저장 공간 변화, CHAR와의 차이점 요약."
description: "VARCHAR 데이터 타입에 대한 개인 학습 노트: 동작 원리, 길이 계산, 문자셋 관계, CHAR 타입과의 비교 등을 중심으로 정리."
toc: true
readTime: true
autonumber: true
math: false
tags: ["Database", "VARCHAR", "CHAR", "DataTypes", "SQL", "CharacterSets", "utf8mb4"]
showTags: true
hideBackToTop: false
---

### 1. VARCHAR

* **정의**: "Variable Character" (가변 문자). 가변 길이 텍스트 저장.
* **선언 예**: `VARCHAR(10)` → 0~10 *문자* 저장 가능.
* **공간 사용**: 실제 저장된 문자열 길이에 따라 공간 사용 (효율적).
* **CHAR(n)과 비교**:
    * `CHAR(n)`: 항상 n 글자에 해당하는 고정 바이트 사용.
    * `VARCHAR(n)`: [실제 텍스트 길이 해당 바이트] + [길이 저장용 1~2 바이트].
* **예시**:
    * "hi" (ASCII, 2바이트)를 `VARCHAR(10)`에 저장 시:
        * 데이터: 2바이트 ("hi")
        * 길이 저장: 1바이트 (10 ≤ 255)
        * 총 사용: 3바이트

### 2. 길이 저장용 추가 바이트 (오버헤드)

* `VARCHAR`는 실제 데이터의 길이를 저장하기 위해 1 또는 2바이트를 추가로 사용.
* **규칙**:
    * `VARCHAR(n)`에서 **n ≤ 255** 이면 → **1바이트** 추가.
    * `VARCHAR(n)`에서 **n > 255** 이면 → **2바이트** 추가.

### 3. 길이 저장 바이트가 필요한 이유

* **핵심**: `VARCHAR`의 "가변 길이" 특성 때문.
* **정확한 데이터 읽기**:
    * 시스템이 먼저 길이 바이트를 읽음 → 실제 데이터의 끝을 정확히 파악.
    * 없으면 데이터 범위 식별 불가.
* **효율적 공간 관리**:
    * 실제 사용된 길이만큼만 저장 가능케 함.
* **데이터 경계 구분**:
    * 저장 공간 내에서 여러 `VARCHAR` 데이터 또는 다른 컬럼 데이터와 명확히 구분.

### 4. CHAR vs VARCHAR 비교

| 특징           | CHAR(n)                                  | VARCHAR(n)                                       |
| :------------- | :--------------------------------------- | :----------------------------------------------- |
| **길이 타입** | 고정 길이                                | 가변 길이                                        |
| **공간 사용** | 항상 n 글자에 해당하는 바이트 (패딩 발생 가능) | 실제 데이터 길이 + 1~2 바이트 (길이 저장)      |
| **길이 정보** | 선언된 길이로 고정 (별도 저장 바이트 X)    | 값마다 실제 길이를 1~2 바이트에 저장 (필수)    |
| **데이터 검색** | 고정 길이만큼 읽음                       | 길이 바이트 읽고 → 해당 길이만큼 실제 데이터 읽음 |

### 5. VARCHAR(n)의 'n'과 실제 바이트 크기 (문자셋 중요!)

* `VARCHAR(n)`의 **'n'은 문자 수 (characters)**, 바이트 수(bytes)가 아님.
* 실제 바이트 크기는 **문자셋(Character Set)**에 따라 결정됨.
* **예시 (`utf8mb4` 문자셋 기준)**:
    * "A" (ASCII) → 1바이트
    * "한" (한글) → 3바이트
    * "😊" (이모지) → 4바이트
* **`VARCHAR(1)`에 "😊" 저장 시 (`utf8mb4`)**:
    * 문자 데이터: 4바이트 ("😊")
    * 길이 저장: 1바이트 (1 ≤ 255)
    * 총 사용: 5바이트
    * 결론: `VARCHAR(1)`이 항상 1바이트(또는 길이 포함 2바이트)를 의미하진 않음.

### 6. VARCHAR(n) 최대 저장 공간 계산 (예: `utf8mb4`)

* `utf8mb4`: 문자당 최대 4바이트 사용.
* **`VARCHAR(100)` (`utf8mb4`)**:
    * 최대 문자 데이터: 100문자 * 4바이트/문자 = 400바이트
    * 길이 저장: 1바이트 (100 ≤ 255)
    * 최대 총 공간: 401바이트
* **`VARCHAR(300)` (`utf8mb4`)**:
    * 최대 문자 데이터: 300문자 * 4바이트/문자 = 1200바이트
    * 길이 저장: 2바이트 (300 > 255)
    * 최대 총 공간: 1202바이트

---